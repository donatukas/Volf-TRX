%
%THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!
%
%---------------------------------------------------------------------------------------------------------
%This is a filter with fixed coefficients.
%This Model Only Support Single Channel Input Data.
%Please input:
%data vector: 		stimulation(1:n)

%    This Model Only Support FIR_WIDTH to 51 Bits

%FILTER PARAMETER
%Input Data Width: 32
%Interpolation Factor: 1
%Decimation Factor: 2
%FIR Width (Full Calculation Width Before Output Width Adjust) :62
%-----------------------------------------------------------------------------------------------------------
%MegaWizard Scaled Coefficient Values

function  output = rx_ciccomp_mlab(stimulation, bank);
 coef_matrix_in= [2,-1,-4,1,7,-1,-10,1,14,-1,-20,0,27,2,-37,-5,50,11,-65,-20,84,33,-108,-52,135,77,-168,-112,206,158,-249,-218,296,296,-347,-394,400,516,-453,-666,504,850,-549,-1070,583,1332,-601,-1639,597,1997,-562,-2408,487,2876,-363,-3404,175,3991,86,-4640,-439,5347,898,-6111,-1481,6925,2204,-7783,-3089,8673,4154,-9584,-5422,10499,6913,-11400,-8650,12263,10654,-13065,-12950,13770,15556,-14351,-18503,14761,21806,-14964,-25499,14900,29599,-14523,-34146,13756,39161,-12538,-44698,10763,50790,-8346,-57520,5133,64946,-989,-73211,-4330,82438,11075,-92897,-19697,104866,30728,-118920,-45166,135765,64421,-156838,-91316,184283,130913,-222746,-195335,281119,316669,-382063,-623079,562474,2097151,2097151,562474,-623079,-382063,316669,281119,-195335,-222746,130913,184283,-91316,-156838,64421,135765,-45166,-118920,30728,104866,-19697,-92897,11075,82438,-4330,-73211,-989,64946,5133,-57520,-8346,50790,10763,-44698,-12538,39161,13756,-34146,-14523,29599,14900,-25499,-14964,21806,14761,-18503,-14351,15556,13770,-12950,-13065,10654,12263,-8650,-11400,6913,10499,-5422,-9584,4154,8673,-3089,-7783,2204,6925,-1481,-6111,898,5347,-439,-4640,86,3991,175,-3404,-363,2876,487,-2408,-562,1997,597,-1639,-601,1332,583,-1070,-549,850,504,-666,-453,516,400,-394,-347,296,296,-218,-249,158,206,-112,-168,77,135,-52,-108,33,84,-20,-65,11,50,-5,-37,2,27,0,-20,-1,14,1,-10,-1,7,1,-4,-1,2];
 INTER_FACTOR  = 1;
 DECI_FACTOR  =  2;
 MSB_RM  = 0;
 MSB_TYPE  = 0;
 LSB_RM  = 0;
 LSB_TYPE  = 1;
 FIR_WIDTH  = 62 + MSB_RM + LSB_RM;
 OUT_WIDTH  = 62 ;  %62
 DATA_WIDTH = 32;

  
 % check size of inputs. 
 DY = size(stimulation, 2);
 CY = size(coef_matrix_in, 2);
 if CY ~= DY * INTER_FACTOR
    fprintf('WARNING : coef_matrix size and input data size does not match\n');
 end 

 %fill coef_matrix to length of data with the latest coef set 
 if CY < DY * INTER_FACTOR
     coef_matrix = coef_matrix_in(bank + 1, :);
   end 
	  
 % check if input is integer 
       	int_sti=round(stimulation); 
	    T = (int_sti ~= stimulation); 
	    if (max(T)~=0) 
	        fprintf('WARNING : Integer Input Expected: Rounding Fractional Input to Nearest Integer...\n'); 
	    end 
	     
	    %Input overflow check 
        %set max/min for signed 
        maxdat = 2^(DATA_WIDTH-1)-1; 
        mindat = -maxdat-1; 

	    %Saturating Input Value 
	    a=find(int_sti>maxdat); 
	    b=find(int_sti<mindat); 
	    if (~isempty(a)|~isempty(b)) 
	 	    fprintf('WARNING : Input Amplitude Exceeds MAXIMUM/MINIMUM allowable values - saturating input values...\n'); 
	            lena = length (a); 
	            lenb = length (b); 
	            for i =1:lena 
	        	    fprintf('%d > %d \n', int_sti(a(i)), maxdat); 
			        int_sti(a(i)) = maxdat; 
		        end 
		    for i =1:lenb 
			    fprintf('%d < %d \n', int_sti(b(i)), mindat); 
			    int_sti(b(i)) = mindat; 
		    end 
	    end 
         
	    % Add interpolation 
   	    inter_sti = zeros(1, INTER_FACTOR * length(int_sti)); 
	    inter_sti(1:INTER_FACTOR:INTER_FACTOR * length(int_sti)) = int_sti; 
 
         
        for i = 1 : DY *INTER_FACTOR 
    	    coef_current = coef_matrix(i,:); 
            output_temp(i) = simp_adaptive (inter_sti, coef_current, i); 
        end 

	% Truncate output 
	len1 = length(output_temp); 
	 
	    switch  LSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_lsb(output_temp,LSB_RM,FIR_WIDTH); 
	    case 1 
	        %round 
            out_dec = bi_round(output_temp,LSB_RM, FIR_WIDTH); 
	    end 
         
 	    switch  MSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_msb(out_dec,MSB_RM,FIR_WIDTH-LSB_RM); 
	    case 1 
	        %round 
            out_dec = bi_satu(out_dec,MSB_RM, FIR_WIDTH-LSB_RM); 
	    end 
 	    
    	% choose decimation output in phase=DECI_FACTOR-1  
     	if(DECI_FACTOR == 1) 
     		output = out_dec; 
else
    output = out_dec(1:DECI_FACTOR:len1);
end

function[output, outindex] = simp_adaptive (int_sti, coef_current, data_index)

	%Simulation is the whole input sequence 
	%coef_current is the current coefficient set 
	%data_index gives the last data to use 
    % output is the sum of input and coef multiplication
	%outindex is the next data_index 
    
    coef_length = length(coef_current);
	data_length = length(int_sti); 
	 
	if (data_index > data_length) 
		fprintf('ERROR: DATA INDEX IS LARGER THAN DATA LENGTH!!!\n'); 
        return
	end 
    min_index = max(data_index - data_length, 1);
    max_index = min(data_index, coef_length);
	 
	outindex= data_index+1; 
    output = int_sti(data_index + 1 - (min_index:max_index)) * coef_current(min_index:max_index).';
 
function output = bi_round(data_in,LSB_RM,ORI_WIDTH)
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width

	data = round (data_in / 2^LSB_RM);

	output = bi_satu(data,0,ORI_WIDTH - LSB_RM); 
	 
function output = bi_trunc_lsb(data_in,LSB_RM,ORI_WIDTH)
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	output = bitshift((2^ORI_WIDTH*(data_in<0)) + (2^LSB_RM)*floor(data_in/(2^LSB_RM)), -LSB_RM) - (2^(ORI_WIDTH-LSB_RM)) *(data_in<0); 
	 
function output = bi_trunc_msb(data_in,MSB_RM,ORI_WIDTH)
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	data = 2^ORI_WIDTH * (data_in < 0)+ data_in; 
	erase_num = 2^(ORI_WIDTH - MSB_RM) - 1; 
	data = bitand(data, erase_num); 
	output = data - 2^(ORI_WIDTH - MSB_RM)*(bitget(data,ORI_WIDTH - MSB_RM)); 
	 
function output = bi_satu(data_in,MSB_RM,ORI_WIDTH)
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	maxdat = 2^(ORI_WIDTH - MSB_RM - 1)-1; 
	mindat = 2^(ORI_WIDTH - MSB_RM - 1)*(-1); 
    data_in(data_in > maxdat) = maxdat;
    data_in(data_in < mindat) = mindat;
	output = data_in; 

